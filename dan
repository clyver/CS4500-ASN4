#!/usr/bin/python
import sys
import os
import sndhdr
import wave
import tempfile
import pdb
import numpy as np
from scipy.io import wavfile
from numpy.fft import fft
"""
This is our dan2 file.  It is our second attempt at accomplishing our semester
project.  In this script you will find command line argument handling, along
with the parsing of wav/mp3 audio files and directories
"""
# We may be making some files that we'll want put in tmp/
if not os.path.exists("tmp/"):
	os.makedirs("tmp/")

"""
We're going to create a dictionary for each data input
key: file_name, value: audio_data
"""
data1_dict = {}
data2_dict = {}

# Some helpers before we get down to business:

def is_mp3(f, directory=""):
	"""
	Determine if file f is in mp3 format.
	directory arg is needed to fine the entire path of a file in a dir
	"""
	if directory:
		f = directory + f
	result = sndhdr.what(f)
	# MP3s should not return a result. We alse want '.mp3' on the end 
	return  result and f.endswith(".mp3")

def mp3_to_wav(f, directory=""):
	"""
	Given this mp3 file, convert it to wav in the tmp/ dir.
	Return the new path to that file
	"""
	if directory:
		f = directory + f
	
	just_file = file_path.rsplit('/', 1)[1] + ".wav"
	mp3_path = "tmp/" + just_file
	
	# Create this audio's wav file in the tmp/ dir
	os.system("/course/cs4500f14/bin/lame --decode --silent {file} \
		 {new_name}".format(file=file_path, new_name=mp3_path))	
	return mp3_path

def file_handler(f, directory=""):
	"""
	Normalize this file.  Chunk it up.  Call fft on chunks.
	Return a list of the highest max for all chunks   
	"""

	if directory:
		f = directory + f
	# Use the wav library to set our channels, sample rate, etc
	x = wave.open(f, 'rb')
	nframes = x.getnframes()
	frames  = x.readframes(nframes)
	x.close()
	temp = tempfile.NamedTemporaryFile(dir="/tmp/")
	ft = wave.open(temp, 'wb')
	ft.setparams((1, 2, 44100, nframes, "NONE", "not compressed"))
	ft.writeframes(frames)
	ft.close()

	# Get the data out of the file we just normalized
	f_sample_rate, f_wav_data = wavfile.read(temp.name)
	# Chunk it up into sub lists of len 4096 (fft likes base 2)
	f_chunked = list(zip(*[iter(f_wav_data)]*4096))

	# FFT each chunk and get the max out of it
	fft_chunk_maxes = []
	for chunk in f_chunked:
		fft_chunk = fft(chunk)
		chunk_max = np.max(fft_chunk)
		fft_chunk_maxes.append(chunk_max)
	
	# Return our list of highest fft chunk values
	return fft_chunk_maxes
	

def dir_breakdown(input_dir, respective_dict):
	"""
	Breakdwon this dir. Iterate over the files. Check for propper formats.
	If the file is good, add its data to the respective dictioanary
	"""
	# Go through the dir's files and ensure all are either wav or mp3
        dir_files = os.listdir(input_dir)
        for f in dir_files:
                # Check  to see if this file is a wav
                if is_mp3(f, input_dir):
                        # Call lame
                        f = mp3_to_wav(f, input_dir)
			
                try:
                        song_data = file_handler(f, input_dir)
                        respective_dict[f] = song_data
                except:
                        print >>sys.stderr, "Error: {f}'s format \
                        is not supported".format(f=f)
			sys.exit(0)
"""Analyze the command line arguments.  Must be in form:
	./dan <-f|-d> <file|dir> <-f|-d> <file|dir>
"""
if len(sys.argv) != 5 or \
   (sys.argv[1] != '-f' and sys.argv[1] != '-d') or \
   (sys.argv[3] != '-f' and sys.argv[3] != '-d'):
        print >>sys.stderr, "ERROR: Incorrect command line."
        sys.exit(0)
# We've done a basic analysis of our input. Set our inputs to a variables
flag1 = sys.argv[1]
data1 = sys.argv[2]
flag2 = sys.argv[3]
data2 = sys.argv[4]

# Let's make sure the provided flags (-f|-d) match the corresponfing input
if flag1 == "-d" and not os.path.isdir(data1):
	print >>sys.stderr, "Error: {data} is not a directory".format(arg=data1)
	sys.exit(0)
if flag2 == "-d" and not os.path.isdir(data2):
	print >>sys.stderr, "Error: {data} is not a directory".format(arg=data2)
        sys.exit(0)
if flag1 == '-f' and os.path.isdir(data1):
        print >>sys.stderr, "ERROR: {arg} is not a file".format(arg=data1)
        sys.exit(0)

if flag2 == '-f' and os.path.isdir(data2):
        print >>sys.stderr, "ERROR: {arg} is not a file".format(arg=sys.data2)
        sys.exit(0)

"""
Now that we know our input is in the correct format, ensure all files are
either wav or mp3 files.   
"""
# Let's know when we are dealing with dirs by asking
data1_is_dir = os.path.isdir(data1)
data2_is_dir = os.path.isdir(data2)

# If dir, hand it off. If it'a a file, call file_handler directly		
if data1_is_dir:
	dir_breakdown(data1, data1_dict)
else:
	song_data = file_handler(data1)
	data1_dict[data1] = song_data

if data2_is_dir:
	dir_breakdown(data2, data2_dict)
else:
	song_data = file_handler(data2)
	data2_dict[data2] = song_data

# ***At this point we have our dicts filled with the data we'll be comparing 
print "data1_dict keys: "
for key in data1_dict.keys():
	print "-", key
print "data2_dict_keys: "
for key in data2_dict.keys():
	print"-", key
print "Let's start comparing using these dicts"
