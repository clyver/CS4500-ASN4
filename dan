#!/usr/bin/python
import sys
import os
import sndhdr
import wave
import tempfile
import pdb
import numpy as np
from scipy.io import wavfile
from numpy.fft import fft
"""
This is our dan file.  It is our second attempt at accomplishing our semester
project.  In this script you will find command line argument handling, an
audio comparator, along with the parsing of wav/mp3 audio files and directories
"""
# We may be making some files that we'll want put in tmp/
if not os.path.exists("tmp/"):
	os.makedirs("tmp/")

"""
We're going to create a dictionary for each data input
key: file_name, value: audio_data
"""
data1_dict = {}
data2_dict = {}

# Some helpers before we get down to business:

def is_mp3(f, directory=""):
	"""
	Determine if file f is in mp3 format.

	"""
	if directory:
                # Make sure we add a '/' if needed
                f = directory + f if directory.endswith('/') else directory + '/' + f

	result = sndhdr.what(f)
	# MP3s should not return a result. We alse want '.mp3' on the end 
	return not result and f.endswith(".mp3")

def short(path):
	"""
	Return the name of the file without any path
	"""
	if '/' in path:
        	return path.rsplit('/', 1)[1]
	else:
		return path
def mp3_to_wav(f, directory=""):
	"""
	Given this mp3 file, convert it to wav in the tmp/ dir.
	Return the new path to that file
	"""
	if directory:
                # Make sure we add a '/' if needed
                f = directory + f if directory.endswith('/') else directory + '/' + f
	
	just_file = short(f) + ".wav"
	mp3_path = "tmp/" + just_file
	
	# Create this audio's wav file in the tmp/ dir
	os.system("/course/cs4500f14/bin/lame --decode --silent {file} \
		 {new_name}".format(file=f, new_name=mp3_path))	
	return mp3_path

def file_handler(f, directory=""):
	"""
	Normalize this file.  Chunk it up.  Call fft on chunks.
	Return a list of the highest max for all chunks   
	"""
	if not "tmp" in f and directory:
                # Make sure we add a '/' if needed
                f = directory + f if directory.endswith('/') else directory + '/' + f


	# Use the wav library to set our channels, sample rate, etc
	x = wave.open(f, 'rb')
	nframes = x.getnframes()
	frames  = x.readframes(nframes)
	x.close()
	temp = tempfile.NamedTemporaryFile(dir="/tmp/")
	ft = wave.open(temp, 'wb')
	ft.setparams((1, 2, 44100, nframes, "NONE", "not compressed"))
	ft.writeframes(frames)
	ft.close()

	# Get the data out of the file we just normalized
	f_sample_rate, f_wav_data = wavfile.read(temp.name)
	# Chunk it up into sub lists of len 4096 (fft likes base 2)
	f_chunked = list(zip(*[iter(f_wav_data)]*4096))

	# FFT each chunk and get the max out of it
	fft_chunk_maxes = []
	for chunk in f_chunked:
		fft_chunk = fft(chunk)
		#freqs = fft_chunk.fftfreq(len(fft_chunk))
		chunk_max = np.max(fft_chunk)
		#chunk_max = np.amax(freqs)
		fft_chunk_maxes.append(chunk_max)
	
	# Return our list of highest fft chunk values
	return fft_chunk_maxes

def get_match_index(max1, l2):
	# Check if this max is present in l2, if so return the index in l2
	i = 0
	while i < len(l2):
		if abs(max1 - l2[i]) < 2000000:
			return i
		else:
			i += 1
	return -1


def matches(p1, p2, threshold):
	# We determine if these two points are close enough, as per threshold
	return abs(p1 - p2) <= threshold

def check_sequence(l1, l2):
	"""
	Given two lists of fft data, print "MATCH" if there is 5 seconds of 
	matching data in the two lists
	"""
	num_errors = 0
	num_match = 0
	j = 0
	f1_len = len(l1)
	f2_len = len(l2)
	limit = f1_len-50
	while j < limit:
		chunk_max = l1[j]	
		# See if there is a match in the other list, else -1
		match_index = get_match_index(chunk_max, l2)
		if match_index >= 0:
			# If there is a match, see if we have 5 seconds
			total_matches = 0
			i = 0
			# We check the remainder of the song for a match
			room_to_check = f2_len - match_index
			# We make p to leave a trail of bread crumbs
			p = j
			# We may want to have some give.  Allow some lenientcy
			slip = 2
			while i < room_to_check:
				# Get the chunk maxes
				l1_chunk_max = l1[p]
				l2_chunk_max = l2[match_index]
				if abs(l1_chunk_max - l2_chunk_max) < 2000000:
					total_matches += 1
					p += 1
					match_index += 1
					i += 1
					if total_matches == 50:
						return True
				else:
					# We see if we have any more slips to use
					if slip:
						slip = slip - 1
						total_matches += 1
                                        	p += 1
                                        	match_index += 1
                                        	i += 1
                                        	if total_matches == 50:
                                                	return True
					else:	
						# We're out of luck
						j += 1
						break
			#If we exit the while loop, we didn't reach 5 seconds of matches
			#TODO: We can tell upfront if we know we won't have enough space
			j +=1 
		else:
			# If no matches, move on and check for more
			j += 1

	return False	

def dir_breakdown(input_dir, respective_dict):
	"""
	Breakdwon this dir. Iterate over the files. Check for propper formats.
	If the file is good, add its data to the respective dictioanary
	"""
	# Go through the dir's files and ensure all are either wav or mp3
        dir_files = os.listdir(input_dir)
        for f in dir_files:
                # Check  to see if this file is a wav
                if is_mp3(f, input_dir):
                        # Call lame
                        f = mp3_to_wav(f, input_dir)
			
                try:
                        song_data = file_handler(f, input_dir)
                        respective_dict[f] = song_data
                except:
                        print >>sys.stderr, "Error: {f}'s format \
                        is not supported".format(f=f)
			sys.exit(0)
"""Analyze the command line arguments.  Must be in form:
	./dan <-f|-d> <file|dir> <-f|-d> <file|dir>
"""
if len(sys.argv) != 5 or \
   (sys.argv[1] != '-f' and sys.argv[1] != '-d') or \
   (sys.argv[3] != '-f' and sys.argv[3] != '-d'):
        print >>sys.stderr, "ERROR: incorrect command line."
        sys.exit(0)
# We've done a basic analysis of our input. Set our inputs to a variables
flag1 = sys.argv[1]
data1 = sys.argv[2]
flag2 = sys.argv[3]
data2 = sys.argv[4]

# Let's make sure the provided flags (-f|-d) match the corresponfing input
if flag1 == "-d" and not os.path.isdir(data1):
	print >>sys.stderr, "Error: {arg} is not a directory".format(arg=data1)
	sys.exit(0)
if flag2 == "-d" and not os.path.isdir(data2):
	print >>sys.stderr, "Error: {arg} is not a directory".format(arg=data2)
        sys.exit(0)
if flag1 == '-f' and not os.path.isfile(data1):
        print >>sys.stderr, "ERROR: {arg} is not a file".format(arg=data1)
        sys.exit(0)

if flag2 == '-f' and not os.path.isfile(data2):
        print >>sys.stderr, "ERROR: {arg} is not a file".format(arg=data2)
        sys.exit(0)

"""
Now that we know our input is in the correct format, ensure all files are
either wav or mp3 files.   
"""
# Let's know when we are dealing with dirs by asking
data1_is_dir = os.path.isdir(data1)
data2_is_dir = os.path.isdir(data2)

# If dir, hand it off. If it'a a file, call file_handler directly		
if data1_is_dir:
	dir_breakdown(data1, data1_dict)
else:
	if is_mp3(data1):
		data1 = mp3_to_wav(data1)
	song_data = file_handler(data1)
	data1_dict[data1] = song_data

if data2_is_dir:
	dir_breakdown(data2, data2_dict)
else:
	if is_mp3(data2):
		data2 = mp3_to_wav(data1)
	song_data = file_handler(data2)
	data2_dict[data2] = song_data

# ***At this point we have our dicts filled with the data we'll be comparing 

"""
# Test code to check the validity of our dictionary keys 
print "data1_dict keys: "
for key in data1_dict.keys():
	print "-", key
print "data2_dict_keys: "
for key in data2_dict.keys():
	print"-", key
"""

# Go through the keys of the data1_dict and compare them to the others
data1_keys = data1_dict.keys()
data2_keys = data2_dict.keys()

# Create a list of what we found already 
found_so_far = []
for key1 in data1_keys:
	for key2 in data2_keys:
		pair = set((key1, key2))
		if pair not in found_so_far: 
			data1_value = data1_dict[key1]
			data2_value = data2_dict[key2]
			if check_sequence(data1_value, data2_value):
				print "MATCH", short(key1), short(key2)
				found_so_far.append(pair) 
