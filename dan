#!/usr/bin/python
import sys
import os
import sndhdr
import wave
import tempfile
import pdb
import numpy as np
from scipy.io import wavfile
from numpy.fft import fft
"""
This is our dan file.  It is our second attempt at accomplishing our semester
project.  In this script you will find command line argument handling, an
audio comparator, along with the parsing of wav/mp3 audio files and directories
"""

# We may be making some files that we'll want put in tmp/HGML
# H.G.M.L Stands for Hsie, Georgescu, Manser, Lyver, the last names of the devs
# This is funny because it sounds like HTML
if not os.path.exists("/tmp/HGML"):
	os.makedirs("/tmp/HGML")

"""
We're going to create a dictionary for each data input
key: file_name, value: audio_data
"""
data1_dict = {}
data2_dict = {}

# Some helpers before we get down to business:
# EDIT: There are actually a hella lot of helper funcs


# Takes a file name f and a string directory path
# Returns true or false based on mp3 format or not
def is_mp3(f, directory=""):
	if directory:
                # Make sure we add a '/' if needed
                f = directory + f if directory.endswith('/')\
		    else directory + '/' + f

	result = sndhdr.what(f)
	# MP3s should not return a result. We alse want '.mp3' on the end 
	return not result and f.endswith(".mp3")

def is_ogg(file):
	# Return True if this file has the .ogg file tag
	return file.endswith(".ogg")

def ogg_to_wav(f, directory=""):
	"""
	Given an ogg file, convert to wav with Linux's oggdec.
	Create the new file in the /tmp directory
	"""

	# Check the validity of the path
	if directory:
                # Make sure we add a '/' if needed
                f = directory + f if directory.endswith('/')\
		    else directory + '/' + f

	just_file = short(f) + ".wav"
	ogg_path = "/tmp/" + just_file

	try:
		os.system("oggdec --quiet -o {f1} {f2}"\
			.format(f1=ogg_path, f2=f))
		# Add this to the list of files we make
		made_files.append(just_file)
		return ogg_path
	except:
		print >> sys.stderr, "{ogg} is not in a supported format".\
			format(ogg=f)
		sys.exit(1)



def short(path):
	"""
	Return the name of the file without any path
	"""
	if '/' in path:
        	return path.rsplit('/', 1)[1]
	else:
		return path

def check_dir_files(directory):
	"""
	We want to ensure that there are no nested directories
	"""

	dir_content = os.listdir(directory)
	for elem in dir_content:
		path = directory + elem
		# If we come across a directory, break
		if not os.path.isfile(path):
			return False
	return True

def reduce_output(path):
	"""
	Ensure we print out the correct file paths
	In particular, if we have a converted file, "test.mp3.wav",
	we want to return test.wav, disregarding that it was converted
	""" 
	if (".wav" and ".mp3" in path) or (".wav" and ".ogg" in path):
		path = path[:-4]
	return path
		

def mp3_to_wav(f, directory=""):
	"""
	Given this mp3 file, convert it to wav in the /tmp/ dir.
	Return the new path to that file
	"""

	# Ensure our path is correct for this file
	if directory:
                # Make sure we add a '/' if needed
                f = directory + f if directory.endswith('/')\
			 else directory + '/' + f
	
	just_file = short(f) + ".wav"
	mp3_path = "/tmp/HGML/" + just_file
	
	# Create this audio's wav file in the /tmp/ dir
	os.system("/course/cs4500f14/bin/lame --decode --silent {file} \
		 {new_name}".format(file=f, new_name=mp3_path))	
	# Add this file to the list of files we've made so far	
	made_files.append(just_file)
	return mp3_path


def file_handler(f, directory=""):
	"""

	Normalize this file.  Chunk it up.  Call fft on chunks.  
	if not "tmp" in f and directory:
                # Make sure we add a '/' if needed
                f = directory + f if directory.endswith('/') else directory + '/' + f
	"""
	
	# Instead of using wave.open use lame to standardize the .wav

	# Standardize .wav file by converting to .mp3 then returning to .wav
	mp3_path = "/tmp/HGML/" + short(f)
	#print mp3_path
	try:
		os.system("/course/cs4500f14/bin/lame --silent --resample 44.1 -a {file}\
			{new_name}".format(file=f, new_name=mp3_path+".mp3"))
	except:
		print >> sys.stderr, "unsuccessful conversion in file_handler wav to mp3"
		sys.exit(1)

	try:
		os.system("/course/cs4500f14/bin/lame --silent --decode {f1} \
		{fname}".format(f1=mp3_path+".mp3", fname=mp3_path))
	except:
		print >> sys.stderr, "unsuccessful conversion in file_handler mp3_to_wav"	

	# Get the data out of the file we just normalized
	f_sample_rate, f_wav_data = wavfile.read(mp3_path)
	# Chunk it up into sub lists of len 4096 (fft likes base 2)
	f_chunked = list(zip(*[iter(f_wav_data)]*4096))

	# FFT each chunk and get the max out of it
	fft_chunk_maxes = []
	for chunk in f_chunked:
		fft_chunk = fft(chunk)
		#freqs = fft_chunk.fftfreq(len(fft_chunk))
		chunk_max = np.max(fft_chunk)
		#chunk_max = np.amax(freqs)
		fft_chunk_maxes.append(chunk_max)
	
	# Return our list of highest fft chunk values
	return fft_chunk_maxes


def get_match_index(max1, l2):
	# Check if this max is present in l2, if so return the index in l2
	i = 0
	while i < len(l2):
		if abs(max1 - l2[i]) < 2000000:
			return i
		else:
			i += 1
	return -1


def matches(p1, p2, threshold):
	# We determine if these two points are close enough, as per threshold
	return abs(p1 - p2) <= threshold

def check_sequence(l1, l2):
	"""
	Given two lists of fft data, print "MATCH" if there is 5 seconds of 
	matching data in the two lists
	"""
	num_errors = 0
	num_match = 0
	j = 0
	f1_len = len(l1)
	f2_len = len(l2)
	limit = f1_len-50
	while j < limit:
		chunk_max = l1[j]	
		# See if there is a match in the other list, else -1
		match_index = get_match_index(chunk_max, l2)
		if match_index >= 0:
			# If there is a match, see if we have 5 seconds
			total_matches = 0
			i = 0
			# We check the remainder of the song for a match
			room_to_check = f2_len - match_index
			# We make p to leave a trail of bread crumbs
			p = j
			# We may want to have some give.  Allow some lenientcy
			slip = 2
			while i < room_to_check:
				# Get the chunk maxes
				l1_chunk_max = l1[p]
				l2_chunk_max = l2[match_index]
				if abs(l1_chunk_max - l2_chunk_max) < 2000000:
					total_matches += 1
					p += 1
					match_index += 1
					i += 1
					if total_matches == 50:
						# Determine when match occured
						f1_match = p/10 - 5
						f2_match = match_index/10 - 5
						return (True,\
						         f1_match, f2_match)
				else:
					# We see if we have slips to use
					if slip:
						slip = slip - 1
						total_matches += 1
                                        	p += 1
                                        	match_index += 1
                                        	i += 1
                                        	if total_matches == 50:
							f1_match = p/10 - 5
							f2_match = \
							 match_index/10 - 5
                                                	return (True, \
							 f1_match, f2_match)
					else:	
						# We're out of luck
						j += 1
						break
			# We didn't reach 5 seconds of matches:
			j +=1 
		else:
			# If no matches, move on and check for more
			j += 1

	return (False, None, None)	

def dir_breakdown(input_dir, respective_dict):
	"""
	Breakdown this dir. Iterate over the files. Check for propper formats.
	If the file is good, add its data to the respective dictioanary
	"""

	# Make sure this directory contains only files
	if not check_dir_files(input_dir):
		print >> sys.stderr, "ERROR: {dir} has a nested directory" \
					.format(dir=input_dir)
		sys.exit(1)

	# Go through the dir's files and ensure all are either wav or mp3
        dir_files = os.listdir(input_dir)
        
	for f in dir_files:
                # Check  to see if this file is a wav, convert if needed

		if is_ogg(f):
			f = ogg_to_wav(f, input_dir)

                elif is_mp3(f, input_dir):
                        # Call lame
                        f = mp3_to_wav(f, input_dir)
			
                try:
                        song_data = file_handler(f, input_dir)
                        respective_dict[f] = song_data
                except:
                        print >> sys.stderr, "Error: {f}'s format \
                        is not supported".format(f=f)
			sys.exit(1)


#  Remove /tmp/HGML/ that we created
def delete_HGMLtmp_dir():
	os.system("rm -r /tmp/HGML/")

#### End of Helper Functions ####


"""Analyze the command line arguments.  Must be in form:
	./dan <-f|-d> <file|dir> <-f|-d> <file|dir>
"""
if len(sys.argv) != 5 or \
   (sys.argv[1] != '-f' and sys.argv[1] != '-d') or \
   (sys.argv[3] != '-f' and sys.argv[3] != '-d'):
        print >>sys.stderr, "ERROR: incorrect command line."
        sys.exit(1)
# We've done a basic analysis of our input. Set our inputs to a variables
flag1 = sys.argv[1]
data1 = sys.argv[2]
flag2 = sys.argv[3]
data2 = sys.argv[4]

# Let's make sure the provided flags (-f|-d) match the corresponfing input
if flag1 == "-d" and not os.path.isdir(data1):
	print >> sys.stderr, \
	 "Error: {arg} is not a directory".format(arg=data1)
	sys.exit(1)
if flag2 == "-d" and not os.path.isdir(data2):
	print >> sys.stderr, \
	 "Error: {arg} is not a directory".format(arg=data2)
        sys.exit(1)
if flag1 == '-f' and not os.path.isfile(data1):
        print >> sys.stderr, \
	 "ERROR: {arg} is not a file".format(arg=data1)
        sys.exit(1)

if flag2 == '-f' and not os.path.isfile(data2):
        print >> sys.stderr, \
	 "ERROR: {arg} is not a file".format(arg=data2)
        sys.exit(1)

"""
Now that we know our input is in the correct format, ensure all files are
either wav or mp3 files.   
"""
# Let's know when we are dealing with dirs by asking
data1_is_dir = os.path.isdir(data1)
data2_is_dir = os.path.isdir(data2)

# If dir, hand it off. If it'a a file, call file_handler directly		
if data1_is_dir:
	dir_breakdown(data1, data1_dict)
else:
	if is_ogg(data1):
		data1 = ogg_to_wav(data1)
	elif is_mp3(data1):
		data1 = mp3_to_wav(data1)
	song_data = file_handler(data1)
	data1_dict[data1] = song_data

if data2_is_dir:
	dir_breakdown(data2, data2_dict)
else:
	if is_ogg(data2):
		data2 = ogg_to_wav(data2)
	elif is_mp3(data2):
		data2 = mp3_to_wav(data2)
	song_data = file_handler(data2)
	data2_dict[data2] = song_data

# ***At this point we have our dicts filled with the data we'll be comparing 

"""
# Test code to check the validity of our dictionary keys 
print "data1_dict keys: "
for key in data1_dict.keys():
	print "-", key
print "data2_dict_keys: "
for key in data2_dict.keys():
	print"-", key
"""

# Go through the keys of the data1_dict and compare them to the others
data1_keys = data1_dict.keys()
data2_keys = data2_dict.keys()

# Create a list of what we found already 
found_so_far = []
for key1 in data1_keys:
	for key2 in data2_keys:
		pair = set((key1, key2))
		if pair not in found_so_far: 
			data1_value = data1_dict[key1]
			data2_value = data2_dict[key2]
			compare_vals = check_sequence(data1_value,\
						      data2_value)
			if compare_vals[0]:
				print "MATCH", \
				 reduce_output(short(key1)), \
				 reduce_output(short(key2)), \
				 compare_vals[1], compare_vals[2]
				found_so_far.append(pair) 

tmp_files = os.listdir("/tmp/")
for f in tmp_files:
	if f in made_files:
		f_path = "/tmp/" + f
		os.remove(f_path)

# remove /tmp/HGML/
delete_HGMLtmp_dir()

# Exit with an exit code of 0
sys.exit(0)
